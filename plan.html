<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>py2dag Plan</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 0; }
    header { padding: 10px 16px; background: #111; color: #eee; font-size: 14px; }
    #container { padding: 12px; }
    svg { width: 100%; height: 80vh; border-top: 1px solid #ddd; }
    .node rect { stroke: #666; fill: #fff; rx: 4; ry: 4; }
    .node.note rect { fill: #fff8dc; }
    .edgePath path { stroke: #333; fill: none; stroke-width: 1.2px; }
  </style>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://unpkg.com/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>
</head>
<body>
  <header>py2dag â€” Dagre graph</header>
  <div id="container">
    <svg><g/></svg>
  </div>
  <script>
    const plan = {"version": 2, "function": "flow", "ops": [{"id": "a_1", "op": "AG1.src", "deps": [], "args": {}, "dep_labels": []}, {"id": "xs_1", "op": "AG1.op", "deps": ["a_1"], "args": {"param2": 42}, "dep_labels": ["param1"]}, {"id": "crossing_info_1", "op": "CONST.value", "deps": [], "args": {"value": null}}, {"id": "iter_1", "op": "ITER.eval", "deps": ["xs_1"], "args": {"expr": "xs", "kind": "for", "target": "x"}}, {"id": "x_1@loop1", "op": "ITER.item", "deps": ["iter_1"], "args": {"target": "x"}}, {"id": "call_1@loop1", "op": "AG3.proc", "deps": ["x_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "crossed_1@loop1", "op": "AG4.op2", "deps": ["x_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "cond_1@loop1", "op": "COND.eval", "deps": ["crossed_1@loop1"], "args": {"expr": "not crossed", "kind": "if"}}, {"id": "approx_time_1@loop1", "op": "AG3.op", "deps": ["x_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "data_1@loop1", "op": "AG4.op", "deps": ["approx_time_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "lat_1@loop1", "op": "GET.item", "deps": ["data_1@loop1"], "args": {"key": "sensor_lat"}}, {"id": "lon_1@loop1", "op": "GET.item", "deps": ["data_1@loop1"], "args": {"key": "sensor_lon"}}, {"id": "call_2@loop1", "op": "AG4.proc", "deps": ["approx_time_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "crossing_info_field_1@loop1", "op": "AG5.op3", "deps": ["approx_time_1@loop1"], "args": {}, "dep_labels": [""]}, {"id": "crossing_info_2@loop1", "op": "PACK.dict", "deps": ["approx_time_1@loop1", "crossing_info_field_1@loop1", "x_1@loop1", "lat_1@loop1", "lon_1@loop1"], "args": {"keys": ["approx_time", "details", "item", "lat", "lon"]}}, {"id": "foreach_1", "op": "COMP.foreach", "deps": ["xs_1"], "args": {"target": "x"}}, {"id": "crossing_info_2", "op": "PHI", "deps": ["crossing_info_1", "crossing_info_2@loop1"], "args": {"var": "crossing_info"}}], "outputs": [{"from": "crossing_info_2", "as": "return"}]};

    function showMessage(msg) {
      const el = document.getElementById('container');
      el.innerHTML = '<div style="padding:12px;color:#b00;background:#fff3f3;border-top:1px solid #f0caca;">' +
        msg + '</div>' +
        '<pre style="margin:0;padding:12px;white-space:pre-wrap;">' +
        (typeof plan === 'object' ? JSON.stringify(plan, null, 2) : '') + '</pre>';
    }

    if (typeof window.d3 === 'undefined' || typeof window.dagreD3 === 'undefined') {
      showMessage('Failed to load Dagre assets (d3/dagre-d3). Check internet connectivity or vendor the JS locally.');
    } else {
      try {
        const g = new dagreD3.graphlib.Graph({ multigraph: true })
          .setGraph({ rankdir: 'LR', nodesep: 30, ranksep: 40 });
        // Ensure edges have an object for labels/attrs to avoid TypeErrors
        g.setDefaultEdgeLabel(() => ({}));

        // Add op nodes with basic styling for control nodes
        (plan.ops || []).forEach(op => {
          let label = op.op;
          let klass = 'op';
          if (op.op === 'COND.eval') {
            const kind = (op.args && op.args.kind) || 'if';
            label = (kind.toUpperCase()) + ' ' + (op.args && op.args.expr ? op.args.expr : '');
            klass = 'note';
          } else if (op.op === 'ITER.eval') {
            label = 'FOR ' + (op.args && op.args.expr ? op.args.expr : '');
            klass = 'note';
          } else if (op.op === 'PHI') {
            label = 'PHI' + (op.args && op.args.var ? ` (${op.args.var})` : '');
            klass = 'note';
          }
          g.setNode(op.id, { label, class: klass, padding: 8 });
        });

        // Add output nodes and edges from source to output
        (plan.outputs || []).forEach(out => {
          const outId = `out:${out.as}`;
          g.setNode(outId, { label: out.as, class: 'note', padding: 8 });
          g.setEdge(out.from, outId);
        });

        // Build index for source op lookup
        const opById = {};
        (plan.ops || []).forEach(op => { opById[op.id] = op; });

        // Add dependency edges between ops with labels
        (plan.ops || []).forEach(op => {
          const depLabels = op.dep_labels || [];
          const seen = new Set();
          (op.deps || []).forEach((dep, idx) => {
            const pair = dep + '->' + op.id;
            if (seen.has(pair)) return; seen.add(pair);
            const src = opById[dep];
            let edgeLabel = (depLabels[idx] || '').toString();
            // Special-cases override when no explicit label was provided
            if (!edgeLabel) {
              if (op.op === 'PACK.dict' && op.args && Array.isArray(op.args.keys)) {
                edgeLabel = (op.args.keys[idx] || '').toString();
              } else if (src && src.op === 'COND.eval') {
                // For IF, label branches as then/else based on dest id; for WHILE keep 'cond'
                const kind = src.args && src.args.kind;
                if (kind === 'if') {
                  if ((op.id || '').includes('@then')) edgeLabel = 'then';
                  else if ((op.id || '').includes('@else')) edgeLabel = 'else';
                  else edgeLabel = 'cond';
                } else {
                  edgeLabel = 'cond';
                }
              } else if (src && src.op === 'ITER.eval') {
                edgeLabel = (src.args && src.args.target) ? src.args.target : 'iter';
              } else {
                edgeLabel = dep; // fallback: SSA id
              }
            }
            g.setEdge(dep, op.id, { label: edgeLabel });
          });
        });

        const svg = d3.select('svg');
        const inner = svg.select('g');
        const render = new dagreD3.render();
        render(inner, g);

        // Centering
        const { width, height } = g.graph();
        const svgWidth = document.querySelector('svg').clientWidth;
        const xCenterOffset = (svgWidth - width) / 2;
        inner.attr('transform', 'translate(' + Math.max(10, xCenterOffset) + ', 20)');
        svg.attr('height', height + 40);
      } catch (e) {
        showMessage('Failed to render Dagre graph: ' + e);
      }
    }
  </script>
</body>
</html>
